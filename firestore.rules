
/**
 * Core Philosophy: This ruleset enforces a public-read model with protected writes.
 * Anonymous and authenticated users can read all public data (products, blogs, etc.).
 * Write operations (creating, updating, deleting) are restricted to authenticated, non-anonymous users for their own data, or admins.
 * Checkout is the primary gate for converting an anonymous user to a permanent one.
 *
 * Data Structure: The database uses a flat, collection-based structure. Key collections include /users, /artisanProfiles, /products, /orders, and /reviews.
 *
 * Key Security Decisions:
 * - Public Read Access: Most top-level collections are world-readable to allow full browsing for anonymous users.
 * - Admin Override: Users with the `role` field set to 'admin' in their `/users/{userId}` document can bypass standard ownership checks.
 * - Write Protection: Create, update, and delete operations are almost always protected by requiring a non-anonymous authenticated user (isNotAnonymous()).
 * - Cart Management: Carts are tied to a user's UID (anonymous or permanent). The rules allow users to manage their own cart. Cart merging happens client-side upon login.
 * - User Role Immutability: A regular user is explicitly forbidden from changing their own `role` field to prevent self-escalation of privileges.
 *
 * Denormalization for Authorization: The rules rely on the `role` field being denormalized directly onto each user's document in the `/users` collection. This allows the `isAdmin()` function to perform a fast, single `get()` operation to determine a user's privileges.
 *
 * Structural Segregation: Each primary data type is stored in its own top-level collection. This separation ensures that security rules are simple and uniform for all documents within a given collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to abstract and reuse security logic.

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }
    
    /**
     * Checks if the user is not anonymous. This is key for protecting write operations.
     */
    function isNotAnonymous() {
      return isSignedIn() && request.auth.token.firebase.sign_in_provider != 'anonymous';
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the foundation of the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document already exists.
     * CRITICAL for safe update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership and existence checks for update/delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Checks if the requesting user has the 'admin' role.
     * This function performs a single document read to the user's own profile.
     */
    function isAdmin() {
      return isNotAnonymous() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * @description Rules for the User collection.
     * @path /users/{userId}
     * @allow (read) Publicly readable to get user profiles for things like artisan pages.
     * @allow (create) An authenticated user creating their own user document.
     * @deny (update) A user trying to change their own role to 'admin'.
     * @principle A user can manage their own data, but admins have override access. Critical fields like 'role' are protected from self-elevation.
     */
    match /users/{userId} {
      allow get, list: if true;
      allow create: if isOwner(userId); // Allows anonymous users to be created for cart persistence
      allow update: if (isOwner(userId) && request.resource.data.role == resource.data.role) || isAdmin();
      allow delete: if isOwner(userId) || isAdmin();

      /**
       * @description Rules for the user's cart subcollection.
       * @path /users/{userId}/cart/{cartItemId}
       * @allow (read, write) Any signed-in user (including anonymous) can manage their own cart.
       * @principle A user has full control over their own cart.
       */
      match /cart/{cartItemId} {
        allow read, write: if isOwner(userId) || isAdmin();
      }

      /**
       * @description Rules for a user's shipping addresses.
       * @path /users/{userId}/shippingAddresses/{addressId}
       * @allow (read, write) A non-anonymous user can manage their own shipping addresses.
       * @principle Data is private to the permanent user, with admin override.
       */
      match /shippingAddresses/{addressId} {
        allow read, list, create, update, delete: if (isOwner(userId) && isNotAnonymous()) || isAdmin();
      }
    }

    /**
     * @description Rules for the Artisan Profiles collection.
     * @path /artisanProfiles/{artisanProfileId}
     * @allow (read) Publicly readable for all users.
     * @principle Data is public to read, but writes are restricted to the owner of the profile or an admin.
     */
    match /artisanProfiles/{artisanProfileId} {
      allow get, list: if true;
      allow create: if isNotAnonymous() && request.resource.data.userId == request.auth.uid;
      allow update: if (isExistingOwner(resource.data.userId) && isNotAnonymous()) || isAdmin();
      allow delete: if (isExistingOwner(resource.data.userId) && isNotAnonymous()) || isAdmin();
    }

    /**
     * @description Rules for the Products collection.
     * @path /products/{productId}
     * @allow (read) Publicly readable for all users.
     * @principle Data is public. Writes are restricted to the linked artisan or an admin.
     */
    match /products/{productId} {
        allow get, list: if true;
        allow create: if (isNotAnonymous() && get(/databases/$(database)/documents/artisanProfiles/$(request.resource.data.artisanId)).data.userId == request.auth.uid) || isAdmin();
        allow update, delete: if (isNotAnonymous() && get(/databases/$(database)/documents/artisanProfiles/$(resource.data.artisanId)).data.userId == request.auth.uid) || isAdmin();
    }

    /**
     * @description Rules for the Orders collection.
     * @path /orders/{orderId}
     * @allow (read) A user can only read their own orders. Admins can read all.
     * @principle Order data is private and only accessible by the customer or an admin.
     */
    match /orders/{orderId} {
      allow get: if (isOwner(resource.data.customerId) && isNotAnonymous()) || isAdmin();
      allow list: if (isNotAnonymous() && request.query.get('customerId') == request.auth.uid) || isAdmin();
      allow create: if (isOwner(request.resource.data.customerId)) || isAdmin(); // Allow anonymous to create order, but it will be pending
      allow update: if (isOwner(resource.data.customerId) && isNotAnonymous()) || isAdmin();
      allow delete: if false; // Orders should generally not be deletable by users.
    }

    /**
     * @description Rules for the OrderItems collection.
     * @path /orderItems/{orderItemId}
     * @principle Access is granted by looking up the parent order document and verifying its owner.
     */
    match /orderItems/{orderItemId} {
      allow get, list: if (isNotAnonymous() && get(/databases/$(database)/documents/orders/$(resource.data.orderId)).data.customerId == request.auth.uid) || isAdmin();
      allow create: if (isOwner(get(/databases/$(database)/documents/orders/$(request.resource.data.orderId)).data.customerId)) || isAdmin();
      allow update, delete: if false; // Order items should not be mutable by users.
    }

    /**
     * @description Rules for the Reviews collection.
     * @path /reviews/{reviewId}
     * @allow (read) Publicly readable.
     * @principle Reviews are public to read, but can only be written or deleted by the original author or an admin.
     */
    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isNotAnonymous() && request.resource.data.customerId == request.auth.uid;
      allow update: if (isExistingOwner(resource.data.customerId) && isNotAnonymous()) || isAdmin();
      allow delete: if (isExistingOwner(resource.data.customerId) && isNotAnonymous()) || isAdmin();
    }
    
    /**
     * @description Rules for the Team Members collection.
     * @path /teamMembers/{memberId}
     * @allow (read) Anyone can view team members.
     * @principle Public read, admin-only write.
     */
    match /teamMembers/{memberId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }
    
    /**
     * @description Rules for the Stores collection.
     * @path /stores/{storeId}
     * @allow (read) Anyone can view store locations.
     * @principle Public read, admin-only write.
     */
    match /stores/{storeId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for the Company Settings collection.
     * @path /companySettings/main
     * @allow (read) Public read for invoice details.
     * @principle Public read, admin-only write for a singleton document.
     */
    match /companySettings/main {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }
    
    /**
     * @description Rules for the Return Requests collection.
     * @path /returnRequests/{returnRequestId}
     * @principle Customer can create and read their own requests. Admin manages status.
     */
    match /returnRequests/{returnRequestId} {
      allow get: if (isOwner(resource.data.customerId) && isNotAnonymous()) || isAdmin();
      allow list: if (isNotAnonymous() && (request.query.get('customerId') == request.auth.uid)) || isAdmin();
      allow create: if isNotAnonymous() && request.resource.data.customerId == request.auth.uid;
      allow update: if isAdmin();
      allow delete: if false; // Returns should not be deleted
    }

    /**
     * @description Rules for the Blogs collection.
     * @path /blogs/{blogId}
     * @allow (read) Published blogs are public. Drafts are admin-only.
     * @principle Content creation is restricted to admins. Published content is public.
     */
    match /blogs/{blogId} {
      allow get: if resource.data.status == 'published' || isAdmin();
      allow list: if true; // Public list access is needed
      allow create, update, delete: if isAdmin();
    }
  }
}
